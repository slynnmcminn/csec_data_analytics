import sys
sys.path.append('C:/Users/cyberarena/Documents/GitHub/csec_data_analytics')
import re
import os
import django
from datetime import datetime, timedelta
# Set up the Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'csec_data_analytics.settings')
django.setup()

# Now you can import your Django models and use them
from csec_data_analytics_app.models import Vulnerability, Weakness
def run_queries():
    vulnerability_count = Vulnerability.objects.count()
    print(f"Total number of vulnerabilities: {vulnerability_count}")

    # Example for attack vector count
    get_attack_vector_count('NETWORK')
    get_attack_vector_count('PHYSICAL')

    # Example for top products with known exploits
    get_top_products_with_known_exploit(10)

def populate_date_added():
    current_time = datetime.now()
    for vulnerability in Vulnerability.objects:
        if not vulnerability.date_added:
            vulnerability.date_added = current_time
            vulnerability.save()

if __name__ == "__main__":
    populate_date_added()

def get_attack_vector_count(attack_vector):
    end_date = datetime.now()
    start_date = end_date - timedelta(days=365)
    attack_vector_count = Vulnerability.objects(
        attack_vector=attack_vector,
        date_added__gte=start_date,
        date_added__lte=end_date
    ).count()
    print(f"There are {attack_vector_count} vulnerabilities with the attack vector {attack_vector} in the past year.")

def get_top_products_with_known_exploit(top_n):
    pipeline = [
        {"$unwind": "$vulnerable_products"},
        {"$match": {"known_exploit": True}},
        {"$group": {
            "_id": {
                "vendor": "$vulnerable_products.vendor",
                "product": "$vulnerable_products.product"
            },
            "count": {"$sum": 1}
        }},
        {"$sort": {"count": -1}},
        {"$limit": top_n}
    ]

    # Run the aggregation
    results = list(Vulnerability.objects.aggregate(pipeline))  # Pass the pipeline directly

    # Print the results
    for i, result in enumerate(results):
        print(f"{i+1}: {result['_id']['vendor']} {result['_id']['product']} has {result['count']} known exploits")
def get_most_common_weakness():
   # Create the aggregation pipeline
   pipeline = [
       {"$unwind": "$weakness"},  # Unwind the weakness array
       {"$group": {
           "_id": "$weakness.type",  # Group by weakness type
           "count": {"$sum": 1}      # Count the occurrences
       }},
       {"$sort": {"count": -1}},  # Sort by count in descending order
       {"$limit": 1}              # Limit to the most common weakness
   ]

   # Run the aggregation
   results = list(Vulnerability.objects().aggregate(*pipeline))


   # Check if any result is found and print it
   if results:
       most_common_weakness = results[0]
       print(f"The most common weakness is '{most_common_weakness['_id']}' with {most_common_weakness['count']} occurrences.")
   else:
       print("No weaknesses found.")


get_most_common_weakness()

def get_vulnerabilities_for_product(product_name):
    end_date = datetime.now()
    start_date = end_date - timedelta(days=120)
    product_name_regex = re.compile(re.escape(product_name), re.IGNORECASE)
    vulnerability_count = Vulnerability.objects(
        vulnerable_products__product=product_name_regex,
        date_added__gte=start_date,
        date_added__lte=end_date
    ).count()
    print(f"There are {vulnerability_count} vulnerabilities for {product_name} in the past 120 days (case-insensitive search).")

if __name__ == "__main__":
    run_queries()

